<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <link rel="stylesheet" href="style.css" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>
</head>
<body>
  <div id="titlebar">
    <div class="title">DPS Viewer</div>
    <div class="title-buttons">
      <button id="min">━</button>
      <button id="close">✕</button>
    </div>
  </div>

  <div id="controls">
    <button id="clearBtn">清空所有数据</button>
    <button id="toggleRealtimeBtn">查看实时伤害</button>
    <button id="opacityBtn">设置透明度</button>
  </div>
  <div id="opacityPanel" style="
    display: none;
    position: absolute;
    top: 50px;
    right: 20px;
    background: rgba(50, 50, 50, 0.9);
    padding: 10px;
    border-radius: 8px;
    z-index: 1000;
  ">
    <label for="opacityRange" style="color: white;">透明度</label>
    <input type="range" id="opacityRange" min="0.2" max="1" step="0.05" value="1" style="width: 150px;" />
  </div>

  <div id="noData" style="display: none;">暂无用户数据</div>

  <div id="chart-container" style=
    "height: auto;
    max-height: 450px;
    overflow-y: auto;
    max-width: 100%;
    overflow-x: hidden;
    ">
    <canvas id="barChart" width="360"></canvas>
  </div>
  

  <script>
    let nicknameMap = {};

    // 加载昵称映射文件
    async function loadNicknameMap() {
      try {
        const res = await fetch('./users.json'); // 确保路径正确
        nicknameMap = await res.json();
        console.log('昵称映射加载成功:', nicknameMap);
          } catch (e) {
        console.warn('加载 users.json 失败,将使用用户ID代替昵称', e);
        // 失败也不影响主功能，继续用ID
        }
  }
    Chart.register(ChartDataLabels);

    const ctx = document.getElementById('barChart').getContext('2d');
    const noDataDiv = document.getElementById('noData');
    const clearBtn = document.getElementById('clearBtn');
    const toggleRealtimeBtn = document.getElementById('toggleRealtimeBtn');
    const opacityPanel = document.getElementById('opacityPanel');
    const opacityRange = document.getElementById('opacityRange');

    let showRealtime = false;

    const barChart = new Chart(ctx, {
      type: 'bar',
      data: {
        labels: [],
        datasets: [{
          label: '总伤害',
          data: [],
          backgroundColor: [],
          borderColor: 'rgba(75, 192, 192, 0.8)',
          borderWidth: 1
        }]
      },
      options: {
        indexAxis: 'y',
        responsive: false,
        maintainAspectRatio: false,
        plugins: {
          legend: { 
            display: true,
            position: 'top',
            align: 'center',
            labels: {
              color: 'white',
              font: {
                size: 10,
                weight: 'bold',
              },
              boxWidth: 0,
              boxHeight: 0,
           },
          },
          datalabels: {
            anchor: 'center',
            align: 'end',
            offset: 4,        // 标签距离柱条末端的像素
            clamp: true,      // 防止标签超出图表区域
            color: 'white',
            font: { weight: 'bold', size: 12 },
            formatter: value => {
              if (value >= 1000000000) {
                return (value / 1000000).toFixed(2) + 'M'; // 以M显示
              } else if (value >= 1000000) {
                return (value / 1000000).toFixed(3) + 'M';
              } else {
                return value.toLocaleString(); // 默认带千位逗号
              }
            }
          },
        },
        scales: {
          x: {
            beginAtZero: true,
            display: false
          },
          y: {
            ticks: {
              autoSkip: false, // 不跳过标签
              font: {
                weight: 'bold',
                size: 12 // 增加字号以提升可读性
              }
            }
          }
        }
      },
      plugins: [ChartDataLabels]
    });

    // 根据输出高低设置柱状图颜色
    function getColorByValue(value, min, max) {
      const colors = [
        'rgba(255, 99, 132, 0.6)',
        'rgba(255, 159, 64, 0.6)',
        'rgba(255, 205, 86, 0.6)',
        'rgba(75, 192, 192, 0.6)',
        'rgba(54, 162, 235, 0.6)'
      ];
      if (min === max) return colors[2];
      const range = max - min || 1;
      const step = range / 5;
      if (value <= min + step) return colors[0];
      else if (value <= min + step * 2) return colors[1];
      else if (value <= min + step * 3) return colors[2];
      else if (value <= min + step * 4) return colors[3];
      else return colors[4];
    }

    // 职业颜色映射表
    const classColorMap_old = {
      '狼弓': 'rgba(255, 99, 132, 0.7)',   // 红色
      '鹰弓': 'rgba(255, 99, 132, 0.7)',
      '冰矛': 'rgba(54, 162, 235, 0.7)',   // 蓝色
      '射线': 'rgba(54, 162, 235, 0.7)',
      '空枪': 'rgba(75, 192, 192, 0.7)',   // 青色
      '重装': 'rgba(75, 192, 192, 0.7)',
      '防盾': 'rgba(255, 205, 86, 0.7)',   // 黄色
      '光盾': 'rgba(255, 205, 86, 0.7)',
      '居合': 'rgba(153, 102, 255, 0.7)',  // 紫色
      '月刃': 'rgba(153, 102, 255, 0.7)',
      '岩盾': 'rgba(165, 42, 42, 0.7)',  // 棕色
      '格挡': 'rgba(165, 42, 42, 0.7)',
      '愈合': 'rgba(0, 100, 0, 0.8)',  // 深绿
      '惩戒': 'rgba(0, 100, 0, 0.8)',
      '协奏': 'rgba(120, 255, 120, 0.7)', // 浅绿
      '狂音': 'rgba(120, 255, 120, 0.7)',
      // 默认颜色（未知职业时使用）
      'default': 'rgba(201, 203, 207, 0.7)' // 灰白
    };

        // 职业颜色映射表
    const classColorMap = {
      '神射手': 'rgba(255, 99, 132, 0.7)',   // 红色
      '冰魔导师': 'rgba(54, 162, 235, 0.7)',   // 蓝色
      '青岚骑士': 'rgba(75, 192, 192, 0.7)',   // 青色
      '神盾骑士': 'rgba(255, 205, 86, 0.7)',   // 黄色
      '雷影剑士': 'rgba(153, 102, 255, 0.7)',  // 紫色
      '巨刃守护者': 'rgba(165, 42, 42, 0.7)',  // 棕色
      '森语者': 'rgba(0, 100, 0, 0.8)',  // 深绿
      '灵魂乐手': 'rgba(120, 255, 120, 0.7)', // 浅绿
      // 默认颜色（未知职业时使用）
      'default': 'rgba(201, 203, 207, 0.7)' // 灰白
    };

    // 根据职业设置设置柱状图颜色
    function getColorByClass(className) {
      return classColorMap[className] || classColorMap['default'];
    }

    // 更新图表
    async function fetchAndUpdate() {
      try {
        const res = await fetch('http://localhost:8989/api/data');
        const data = await res.json();

        const users = Object.entries(data.user || {}).map(([id, info]) => ({
          id,
          total: info.total_damage.total,
          total_dps: info.total_dps || 0,
          total_heal: info.total_healing.total || 0,
          class_name: info.profession,
          user_name: info.name || id,
        }));

        const filteredUsers = users.filter(u => u.total > 0);

        const sortedUsers = filteredUsers.sort((a, b) => {
          return showRealtime ? b.total_dps - a.total_dps : b.total - a.total;
        });

        const topUsers = sortedUsers.slice(0, 20);
        adjustChartHeight(topUsers.length);

        if (topUsers.length === 0) {
          barChart.data.labels = [];
          barChart.data.datasets[0].data = [];
          barChart.data.datasets[0].backgroundColor = [];
          barChart.update();
          noDataDiv.style.display = 'block';
          return;
        } else {
          noDataDiv.style.display = 'none';

          // const labels = topUsers.map(u => {return nicknameMap[u.id] || u.id; }); // 使用昵称，找不到就用ID
          const labels = topUsers.map(u => u.user_name);
          let label;


          if (showRealtime) {
            values = topUsers.map(u => u.total_dps.toFixed(1));
            label = '秒均伤害';
          } else {
            values = topUsers.map(u => u.total);
            label = '总伤害';
          }

          // minVal = Math.min(...values);
          // maxVal = Math.max(...values);
          // colors = values.map(v => getColorByValue(v, minVal, maxVal)); // 根据数值上色

          const colors = topUsers.map(u => getColorByClass(u.class_name)); // 根据职业上色
          // console.log('当前职业列表:', [...new Set(topUsers.map(u => u.class_name))]);  //debug
          // console.log('当前玩家昵称:', [...new Set(topUsers.map(u => u.user_name))]); //debug

          barChart.data.labels = labels;
          barChart.data.datasets[0].label = label;
          barChart.data.datasets[0].data = values;
          barChart.data.datasets[0].backgroundColor = colors;

          barChart.update();
        }
      } catch (e) {
        noDataDiv.textContent = '数据加载失败';
        noDataDiv.style.display = 'block';
        console.error('请求失败:', e);
      }
    }

    function adjustChartHeight(userCount) {
      const rowHeight = 35; // 每个用户的高度（可根据需要调整）
      const minHeight = 70; // 最小高度限制
      const canvasHeight = Math.max(userCount * rowHeight, minHeight);

      const chartCanvas = document.getElementById('barChart');

      chartCanvas.height = canvasHeight;
      chartCanvas.style.height = `${canvasHeight}px`;

      if (barChart) {
        barChart.resize();
      }
}

    clearBtn.onclick = async () => {
      try {
        const res = await fetch('http://localhost:8989/api/clear');
        if (res.ok) {
          // alert('数据已清空');
          fetchAndUpdate();
        } else {
          alert('清空失败');
        }
      } catch (e) {
        alert('清空请求失败');
        console.error(e);
      }
    };

    async function init() {
      // await loadNicknameMap();        // 先加载昵称
      fetchAndUpdate();               // 再获取数据
      setInterval(fetchAndUpdate, 1000);
    }

    init(); // 启动

    toggleRealtimeBtn.onclick = () => {
      showRealtime = !showRealtime;
      toggleRealtimeBtn.textContent = showRealtime ? '查看总伤害' : '查看秒均伤害';
      fetchAndUpdate();
    };

    document.getElementById('min').addEventListener('click', () => {
      window.electronAPI?.minimize();
    });
    document.getElementById('close').addEventListener('click', () => {
      window.electronAPI?.close();
    });
    opacityBtn.onclick = () => {
      const current = parseFloat(document.body.style.opacity || "1");
      opacityRange.value = current;
      opacityPanel.style.display = (opacityPanel.style.display === 'none') ? 'block' : 'none';
    };

    // 滑动时实时更新透明度
    opacityRange.oninput = () => {
      document.body.style.opacity = opacityRange.value;
    };
    // 点击其他区域隐藏滑块面板
    document.addEventListener('click', (e) => {
      if (!opacityPanel.contains(e.target) && e.target !== opacityBtn) {
        opacityPanel.style.display = 'none';
      }
    });
    document.addEventListener('keydown', (e) => {
      if (e.key === 'F4' && document.activeElement.tagName !== 'INPUT') {
    clearBtn.click();
    }
    });
  </script>
</body>
</html>
